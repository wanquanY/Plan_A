from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
from sqlalchemy import select, func

from backend.db.session import get_db
from backend.api.deps import get_db as get_async_db, get_current_user
from backend.models.user import User
from backend.models.note import Note
from backend.models.chat import Chat
from backend.schemas.note import NoteCreate, NoteUpdate, NoteResponse, NoteList
from backend.core.response import SuccessResponse, ErrorResponse
from backend.services.memory import memory_service
from backend.services.chat import get_chat_messages
from backend.utils.logging import api_logger
from backend.crud.note_session import note_session
from backend.crud.chat import get_chat_messages, get_chat
from backend.utils.id_converter import IDConverter

router = APIRouter()


@router.post("/")
async def create_note(
    request: Request,
    note_data: NoteCreate,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """åˆ›å»ºæ–°ç¬”è®°"""
    try:
        # åˆ›å»ºæ–°ç¬”è®°ï¼Œä¸å†è‡ªåŠ¨åˆ›å»ºä¼šè¯
        new_note = Note(
            user_id=current_user.id,
            title=note_data.title if note_data.title is not None else "",  # å¦‚æœæ ‡é¢˜ä¸ºNoneåˆ™è®¾ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œä¸å†ä½¿ç”¨é»˜è®¤æ ‡é¢˜
            content=note_data.content or "",
            is_public=note_data.is_public or False
        )
        db.add(new_note)
        await db.commit()
        await db.refresh(new_note)
        
        return SuccessResponse(
            data={
                "note_id": new_note.public_id,
                "title": new_note.title,
                "session_id": None  # æ–°åˆ›å»ºçš„ç¬”è®°æ²¡æœ‰å…³è”ä¼šè¯
            },
            msg="ç¬”è®°åˆ›å»ºæˆåŠŸ",
            request_id=getattr(request.state, "request_id", None)
        )
    except IntegrityError as e:
        await db.rollback()
        raise HTTPException(status_code=400, detail=f"åˆ›å»ºç¬”è®°å¤±è´¥: {str(e)}")
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"åˆ›å»ºç¬”è®°æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.get("/")
async def get_notes(
    request: Request,
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """è·å–ç”¨æˆ·çš„ç¬”è®°åˆ—è¡¨ - æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬"""
    try:
        # è·å–ç”¨æˆ·ç¬”è®°æ€»æ•°
        count_stmt = select(func.count()).select_from(Note).where(
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        total_result = await db.execute(count_stmt)
        total = total_result.scalar()
        
        # è·å–åˆ†é¡µçš„ç¬”è®°åˆ—è¡¨
        stmt = select(Note).where(
            Note.user_id == current_user.id,
            Note.is_deleted == False
        ).order_by(Note.updated_at.desc()).offset(skip).limit(limit)
        
        notes_result = await db.execute(stmt)
        notes = notes_result.scalars().all()
        
        # ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡è·å–æ‰€æœ‰éœ€è¦çš„ä¼šè¯ID
        all_note_ids = [note.id for note in notes]
        primary_sessions = await note_session.batch_get_primary_sessions_by_notes(db, all_note_ids)
        
        # ğŸš€ æ‰¹é‡è½¬æ¢ä¼šè¯IDä¸ºpublic_id
        session_db_ids = [ps.id for ps in primary_sessions.values() if ps]
        session_id_map = await IDConverter.batch_get_public_ids(db, session_db_ids, Chat)
        
        # æ„å»ºå“åº”åˆ—è¡¨
        notes_list = []
        for note in notes:
            # è·å–ä¸»è¦ä¼šè¯IDï¼ˆå·²ä¼˜åŒ–ä¸ºæ‰¹é‡æŸ¥è¯¢ï¼‰
            primary_session = primary_sessions.get(note.id)
            session_id = session_id_map.get(primary_session.id) if primary_session else None
            
            notes_list.append({
                "id": note.public_id,
                "title": note.title,
                "session_id": session_id,
                "is_public": note.is_public,
                "created_at": note.created_at.isoformat() if note.created_at else None,
                "updated_at": note.updated_at.isoformat() if note.updated_at else None
            })
        
        return SuccessResponse(
            data={
                "notes": notes_list,
                "total": total,
                "skip": skip,
                "limit": limit
            },
            msg="è·å–ç¬”è®°åˆ—è¡¨æˆåŠŸ",
            request_id=getattr(request.state, "request_id", None)
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ç¬”è®°åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.get("/{note_id}")
async def get_note(
    request: Request,
    note_id: str,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """è·å–ç¬”è®°è¯¦æƒ…"""
    try:
        # éªŒè¯ç¬”è®°å­˜åœ¨æ€§
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        if not db_note_id:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–å·²åˆ é™¤", request_id=getattr(request.state, "request_id", None))
        
        # è·å–ç¬”è®°çš„ä¸»è¦ä¼šè¯
        primary_session = await note_session.get_primary_session_by_note(db, note_id)
        session_id = primary_session.public_id if primary_session else None
        
        # å¦‚æœç¬”è®°å…³è”äº†ä¼šè¯ï¼Œå°è¯•æ¢å¤ä¼šè¯è®°å¿†åˆ°Redis
        if primary_session:
            try:
                # è·å–ä¼šè¯è®°å¿†å½“å‰çŠ¶æ€ï¼ˆmemory_serviceå·²æ”¯æŒpublic_idï¼‰
                memory_messages = memory_service.get_messages(primary_session.public_id)
                
                # å¦‚æœRedisä¸­æ²¡æœ‰è¯¥ä¼šè¯çš„è®°å¿†ï¼Œåˆ™å°è¯•ä»æ•°æ®åº“æ¢å¤
                if not memory_messages:
                    api_logger.info(f"ç¬”è®° {note_id} å…³è”çš„ä¼šè¯ {primary_session.public_id} åœ¨Redisä¸­æ²¡æœ‰è®°å¿†ï¼Œå°è¯•æ¢å¤")
                    
                    # è·å–ä¼šè¯å†å²æ¶ˆæ¯ï¼ˆget_chat_messageså·²æ”¯æŒpublic_idï¼‰
                    db_messages = await get_chat_messages(db, primary_session.public_id)
                    
                    # æ ¼å¼åŒ–æ¶ˆæ¯å¹¶æ¢å¤åˆ°Redis
                    formatted_messages = [
                        {"role": msg.role, "content": msg.content}
                        for msg in db_messages
                        if not msg.is_deleted
                    ]
                    
                    # æ¢å¤è®°å¿†ï¼Œä¼ é€’ç”¨æˆ·IDè¿›è¡Œç®¡ç†ï¼ˆmemory_serviceå·²æ”¯æŒpublic_idï¼‰
                    restored = memory_service.restore_memory_from_db(primary_session.public_id, formatted_messages, current_user.id)
                    if restored:
                        api_logger.info(f"å·²è‡ªåŠ¨æ¢å¤ç¬”è®° {note_id} å…³è”çš„ä¼šè¯ {primary_session.public_id} è®°å¿†ï¼Œå…± {len(formatted_messages)} æ¡æ¶ˆæ¯")
                    else:
                        api_logger.warning(f"ç¬”è®° {note_id} å…³è”çš„ä¼šè¯ {primary_session.public_id} æ²¡æœ‰å¯æ¢å¤çš„å†å²æ¶ˆæ¯")
            except Exception as e:
                # æ¢å¤è®°å¿†å¤±è´¥ä¸å½±å“ç¬”è®°è·å–
                api_logger.error(f"è‡ªåŠ¨æ¢å¤ç¬”è®° {note_id} å…³è”çš„ä¼šè¯ {primary_session.public_id} è®°å¿†å¤±è´¥: {str(e)}", exc_info=True)
        
        # è·å–æ‰€æœ‰å…³è”çš„ä¼šè¯ï¼ˆnote_sessionå·²æ”¯æŒpublic_idï¼‰
        sessions = await note_session.get_sessions_by_note(db, note_id)
        primary_session = await note_session.get_primary_session_by_note(db, note_id)
        
        session_list = []
        for session in sessions:
            # è·å–ä¼šè¯çš„æ¶ˆæ¯æ•°é‡å’Œæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆget_chat_messageså·²æ”¯æŒpublic_idï¼‰
            messages = await get_chat_messages(db, session.public_id)
            message_count = len(messages) if messages else 0
            
            # è·å–æœ€åä¸€æ¡æ¶ˆæ¯å†…å®¹
            last_message = None
            if message_count > 0:
                # ç›´æ¥ä½¿ç”¨å®Œæ•´çš„æ¶ˆæ¯å†…å®¹ï¼Œä¸è¿›è¡Œæˆªæ–­
                last_message = messages[-1].content if messages[-1].content else None
            
            # å®‰å…¨åœ°è·å–agent_idï¼Œé¿å…æ‡’åŠ è½½é—®é¢˜
            agent_public_id = None
            if session.agent_id:
                agent_public_id = await IDConverter.get_agent_public_id(db, session.agent_id)
            
            session_info = {
                "id": session.public_id,
                "title": session.title,
                "is_primary": session.id == (primary_session.id if primary_session else None),
                "agent_id": agent_public_id,
                "message_count": message_count,
                "last_message": last_message,
                "created_at": session.created_at.isoformat() if session.created_at else None,
                "updated_at": session.updated_at.isoformat() if session.updated_at else None
            }
            session_list.append(session_info)
        
        return SuccessResponse(
            data={
                "id": note.public_id,
                "user_id": note.user.public_id if note.user else None,
                "title": note.title,
                "content": note.content,
                "session_id": session_id,
                "last_edited_position": note.last_edited_position,
                "is_public": note.is_public,
                "share_link": note.share_link,
                "created_at": note.created_at.isoformat() if note.created_at else None,
                "updated_at": note.updated_at.isoformat() if note.updated_at else None,
                "sessions": session_list
            },
            msg="è·å–ç¬”è®°è¯¦æƒ…æˆåŠŸ",
            request_id=getattr(request.state, "request_id", None)
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ç¬”è®°è¯¦æƒ…æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.put("/{note_id}")
async def update_note(
    request: Request,
    note_id: str,
    note_data: NoteUpdate,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """æ›´æ–°ç¬”è®°"""
    try:
        # éªŒè¯ç¬”è®°å­˜åœ¨æ€§
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        if not db_note_id:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–å·²åˆ é™¤", request_id=getattr(request.state, "request_id", None))
        
        # æ›´æ–°ç¬”è®°å­—æ®µ
        if note_data.title is not None:
            note.title = note_data.title
        if note_data.content is not None:
            note.content = note_data.content
        if note_data.last_edited_position is not None:
            note.last_edited_position = note_data.last_edited_position
        if note_data.is_public is not None:
            note.is_public = note_data.is_public
        
        await db.commit()
        await db.refresh(note)
        
        return SuccessResponse(
            data={
                "id": note.public_id,
                "title": note.title,
                "content": note.content,
                "last_edited_position": note.last_edited_position,
                "is_public": note.is_public,
                "updated_at": note.updated_at.isoformat() if note.updated_at else None
            },
            msg="ç¬”è®°æ›´æ–°æˆåŠŸ",
            request_id=getattr(request.state, "request_id", None)
        )
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"æ›´æ–°ç¬”è®°æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.delete("/{note_id}")
async def delete_note(
    request: Request,
    note_id: str,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """åˆ é™¤ç¬”è®°"""
    try:
        # éªŒè¯ç¬”è®°å­˜åœ¨æ€§
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        if not db_note_id:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–å·²åˆ é™¤", request_id=getattr(request.state, "request_id", None))
        
        # è½¯åˆ é™¤ç¬”è®°
        note.is_deleted = True
        await db.commit()
        
        return SuccessResponse(
            data={"deleted_note_id": note.public_id},
            msg="ç¬”è®°åˆ é™¤æˆåŠŸ",
            request_id=getattr(request.state, "request_id", None)
        )
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"åˆ é™¤ç¬”è®°æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.post("/{note_id}/edit")
async def edit_note_by_agent(
    request: Request,
    note_id: str,
    edit_data: dict,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """Agentç¼–è¾‘ç¬”è®°å†…å®¹çš„ä¸“ç”¨ç«¯ç‚¹"""
    try:
        # å°†public_idè½¬æ¢ä¸ºæ•°æ®åº“ID
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        if not db_note_id:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        # éªŒè¯ç¬”è®°å­˜åœ¨ä¸”å±äºå½“å‰ç”¨æˆ·
        stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–å·²åˆ é™¤", request_id=getattr(request.state, "request_id", None))
        
        # è·å–ç¼–è¾‘å‚æ•°
        edit_type = edit_data.get("edit_type", "replace")
        content = edit_data.get("content")
        title = edit_data.get("title")
        start_line = edit_data.get("start_line")
        end_line = edit_data.get("end_line")
        insert_position = edit_data.get("insert_position")
        search_text = edit_data.get("search_text")
        replace_text = edit_data.get("replace_text")
        
        # è®°å½•ç¼–è¾‘å‰çš„çŠ¶æ€
        original_content = note.content or ""
        original_title = note.title or ""
        
        # æ‰§è¡Œç¼–è¾‘æ“ä½œ
        new_content = original_content
        new_title = title if title is not None else original_title
        
        if edit_type == "replace":
            # å®Œå…¨æ›¿æ¢å†…å®¹
            if content is not None:
                new_content = content
                
        elif edit_type == "append":
            # è¿½åŠ å†…å®¹
            if content is not None:
                new_content = original_content + "\n" + content if original_content else content
                
        elif edit_type == "prepend":
            # å‰ç½®å†…å®¹
            if content is not None:
                new_content = content + "\n" + original_content if original_content else content
                
        elif edit_type == "insert":
            # åœ¨æŒ‡å®šä½ç½®æ’å…¥å†…å®¹
            if content is not None and insert_position:
                lines = original_content.split('\n')
                
                if insert_position == "start":
                    new_content = content + "\n" + original_content if original_content else content
                elif insert_position == "end":
                    new_content = original_content + "\n" + content if original_content else content
                elif insert_position.startswith("after_line:"):
                    try:
                        line_num = int(insert_position.split(":")[1])
                        if 0 <= line_num <= len(lines):
                            lines.insert(line_num, content)
                            new_content = '\n'.join(lines)
                        else:
                            return ErrorResponse(msg=f"è¡Œå· {line_num} è¶…å‡ºèŒƒå›´", request_id=getattr(request.state, "request_id", None))
                    except ValueError:
                        return ErrorResponse(msg="æ— æ•ˆçš„è¡Œå·æ ¼å¼", request_id=getattr(request.state, "request_id", None))
                elif insert_position.startswith("before_line:"):
                    try:
                        line_num = int(insert_position.split(":")[1])
                        if 1 <= line_num <= len(lines) + 1:
                            lines.insert(line_num - 1, content)
                            new_content = '\n'.join(lines)
                        else:
                            return ErrorResponse(msg=f"è¡Œå· {line_num} è¶…å‡ºèŒƒå›´", request_id=getattr(request.state, "request_id", None))
                    except ValueError:
                        return ErrorResponse(msg="æ— æ•ˆçš„è¡Œå·æ ¼å¼", request_id=getattr(request.state, "request_id", None))
                else:
                    return ErrorResponse(msg="æ— æ•ˆçš„æ’å…¥ä½ç½®æ ¼å¼", request_id=getattr(request.state, "request_id", None))
                    
        elif edit_type == "replace_lines":
            # æ›¿æ¢æŒ‡å®šè¡ŒèŒƒå›´
            if content is not None and start_line is not None:
                lines = original_content.split('\n')
                end_line_actual = end_line if end_line is not None else start_line
                
                if 1 <= start_line <= len(lines) and 1 <= end_line_actual <= len(lines):
                    # æ›¿æ¢æŒ‡å®šè¡ŒèŒƒå›´
                    new_lines = content.split('\n')
                    lines[start_line-1:end_line_actual] = new_lines
                    new_content = '\n'.join(lines)
                else:
                    return ErrorResponse(msg=f"è¡Œå·èŒƒå›´ {start_line}-{end_line_actual} è¶…å‡ºèŒƒå›´", request_id=getattr(request.state, "request_id", None))
                    
        elif edit_type == "replace_text":
            # æ›¿æ¢æŒ‡å®šæ–‡æœ¬
            if search_text is not None and replace_text is not None:
                if search_text in original_content:
                    new_content = original_content.replace(search_text, replace_text)
                else:
                    return ErrorResponse(msg=f"æœªæ‰¾åˆ°è¦æ›¿æ¢çš„æ–‡æœ¬: {search_text}", request_id=getattr(request.state, "request_id", None))
            else:
                return ErrorResponse(msg="replace_text ç±»å‹éœ€è¦æä¾› search_text å’Œ replace_text å‚æ•°", request_id=getattr(request.state, "request_id", None))
        else:
            return ErrorResponse(msg=f"ä¸æ”¯æŒçš„ç¼–è¾‘ç±»å‹: {edit_type}", request_id=getattr(request.state, "request_id", None))
        
        # æ›´æ–°ç¬”è®°
        note.content = new_content
        note.title = new_title
        
        await db.commit()
        await db.refresh(note)
        
        # è®¡ç®—å˜åŒ–ç»Ÿè®¡
        original_lines = original_content.split('\n')
        new_lines = new_content.split('\n')
        
        return SuccessResponse(
            data={
                "note_id": note.public_id,
                "title": note.title,
                "edit_type": edit_type,
                "changes": {
                    "original_length": len(original_content),
                    "new_length": len(new_content),
                    "original_lines": len(original_lines),
                    "new_lines": len(new_lines),
                    "title_changed": original_title != new_title
                },
                "updated_at": note.updated_at.isoformat() if note.updated_at else None,
                "content": new_content  # è¿”å›å®Œæ•´çš„æ–°å†…å®¹ä¾›å‰ç«¯æ›´æ–°
            },
            msg="ç¬”è®°ç¼–è¾‘æˆåŠŸ",
            request_id=getattr(request.state, "request_id", None)
        )
        
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"ç¼–è¾‘ç¬”è®°æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.post("/{note_id}/apply-edit")
async def apply_edit_preview(
    request: Request,
    note_id: str,
    edit_data: dict,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """åº”ç”¨é¢„è§ˆç¼–è¾‘åˆ°ç¬”è®°"""
    try:
        # å°†public_idè½¬æ¢ä¸ºæ•°æ®åº“ID
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        if not db_note_id:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        # éªŒè¯ç¬”è®°å­˜åœ¨ä¸”å±äºå½“å‰ç”¨æˆ·
        stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–å·²åˆ é™¤", request_id=getattr(request.state, "request_id", None))
        
        # åº”ç”¨ç¼–è¾‘
        if edit_data.get("content") is not None:
            note.content = edit_data["content"]
        
        if edit_data.get("title") is not None:
            note.title = edit_data["title"]
        
        # ä¿å­˜æ›´æ”¹
        await db.commit()
        await db.refresh(note)
        
        api_logger.info(f"ç”¨æˆ· {current_user.public_id} åº”ç”¨é¢„è§ˆç¼–è¾‘åˆ°ç¬”è®° {note_id}")
        
        return SuccessResponse(
            data={
                "id": note.public_id,
                "title": note.title,
                "content": note.content,
                "updated_at": note.updated_at.isoformat() if note.updated_at else None
            },
            msg="ç¼–è¾‘å·²åº”ç”¨å¹¶ä¿å­˜",
            request_id=getattr(request.state, "request_id", None)
        )
        
    except Exception as e:
        api_logger.error(f"åº”ç”¨é¢„è§ˆç¼–è¾‘å¤±è´¥: {str(e)}", exc_info=True)
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"åº”ç”¨ç¼–è¾‘æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.post("/{note_id}/sessions/{session_id}/link")
async def link_note_to_session(
    request: Request,
    note_id: str,
    session_id: str,
    is_primary: bool = False,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """å°†ç¬”è®°å…³è”åˆ°ä¼šè¯"""
    try:
        # éªŒè¯ç¬”è®°å’Œä¼šè¯éƒ½å­˜åœ¨ä¸”å±äºå½“å‰ç”¨æˆ·ï¼ˆæš‚æ—¶ä¿ç•™IDè½¬æ¢ç”¨äºéªŒè¯ï¼‰
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        db_session_id = await IDConverter.get_chat_db_id(db, session_id)
        
        if not db_note_id or not db_session_id:
            return ErrorResponse(msg="ç¬”è®°æˆ–ä¼šè¯ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        # éªŒè¯ç¬”è®°å±äºå½“å‰ç”¨æˆ·
        note_stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(note_stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–æ— æƒé™", request_id=getattr(request.state, "request_id", None))
        
        # éªŒè¯ä¼šè¯å±äºå½“å‰ç”¨æˆ·ï¼ˆget_chatå·²æ”¯æŒpublic_idï¼‰
        session = await get_chat(db, session_id)
        if not session or session.user_id != current_user.id:
            return ErrorResponse(msg="ä¼šè¯ä¸å­˜åœ¨æˆ–æ— æƒé™", request_id=getattr(request.state, "request_id", None))
        
        # åˆ›å»ºå…³è”ï¼ˆnote_sessionå·²æ”¯æŒpublic_idï¼‰
        await note_session.create_note_session_link(
            db,
            note_id=note_id,  # ç›´æ¥ä½¿ç”¨public_id
            session_id=session_id,  # ç›´æ¥ä½¿ç”¨public_id
            is_primary=is_primary
        )
        
        return SuccessResponse(
            data={
                "note_id": note_id,
                "session_id": session_id,
                "is_primary": is_primary
            },
            msg="å…³è”åˆ›å»ºæˆåŠŸ",
            request_id=getattr(request.state, "request_id", None)
        )
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"åˆ›å»ºå…³è”æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.delete("/{note_id}/sessions/{session_id}/unlink")
async def unlink_note_from_session(
    request: Request,
    note_id: str,
    session_id: str,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """å–æ¶ˆç¬”è®°ä¸ä¼šè¯çš„å…³è”"""
    try:
        # éªŒè¯æƒé™ï¼ˆæš‚æ—¶ä¿ç•™IDè½¬æ¢ç”¨äºéªŒè¯ï¼‰
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        if not db_note_id:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        # éªŒè¯ç¬”è®°å±äºå½“å‰ç”¨æˆ·
        note_stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(note_stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–æ— æƒé™", request_id=getattr(request.state, "request_id", None))
        
        # ç§»é™¤å…³è”ï¼ˆnote_sessionå·²æ”¯æŒpublic_idï¼‰
        success = await note_session.remove_note_session_link(
            db,
            note_id=note_id,  # ç›´æ¥ä½¿ç”¨public_id
            session_id=session_id  # ç›´æ¥ä½¿ç”¨public_id
        )
        
        if success:
            return SuccessResponse(
                data={
                    "note_id": note_id,
                    "session_id": session_id
                },
                msg="å…³è”å·²ç§»é™¤",
                request_id=getattr(request.state, "request_id", None)
            )
        else:
            return ErrorResponse(msg="å…³è”ä¸å­˜åœ¨æˆ–ç§»é™¤å¤±è´¥", request_id=getattr(request.state, "request_id", None))
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"ç§»é™¤å…³è”æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.put("/{note_id}/sessions/{session_id}/set-primary")
async def set_primary_session(
    request: Request,
    note_id: str,
    session_id: str,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """è®¾ç½®ç¬”è®°çš„ä¸»è¦ä¼šè¯"""
    try:
        # éªŒè¯æƒé™ï¼ˆæš‚æ—¶ä¿ç•™IDè½¬æ¢ç”¨äºéªŒè¯ï¼‰
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        if not db_note_id:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        # éªŒè¯ç¬”è®°å±äºå½“å‰ç”¨æˆ·
        note_stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(note_stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–æ— æƒé™", request_id=getattr(request.state, "request_id", None))
        
        # è®¾ç½®ä¸»è¦ä¼šè¯ï¼ˆnote_sessionå·²æ”¯æŒpublic_idï¼‰
        success = await note_session.set_primary_session(
            db,
            note_id=note_id,  # ç›´æ¥ä½¿ç”¨public_id
            session_id=session_id  # ç›´æ¥ä½¿ç”¨public_id
        )
        
        if success:
            return SuccessResponse(
                data={
                    "note_id": note_id,
                    "session_id": session_id,
                    "is_primary": True
                },
                msg="ä¸»è¦ä¼šè¯è®¾ç½®æˆåŠŸ",
                request_id=getattr(request.state, "request_id", None)
            )
        else:
            return ErrorResponse(msg="è®¾ç½®ä¸»è¦ä¼šè¯å¤±è´¥", request_id=getattr(request.state, "request_id", None))
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=f"è®¾ç½®ä¸»è¦ä¼šè¯æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")


@router.get("/{note_id}/sessions")
async def get_note_sessions(
    request: Request,
    note_id: str,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user)
):
    """è·å–ç¬”è®°çš„æ‰€æœ‰å…³è”ä¼šè¯"""
    try:
        # éªŒè¯æƒé™ï¼ˆæš‚æ—¶ä¿ç•™IDè½¬æ¢ç”¨äºéªŒè¯ï¼‰
        db_note_id = await IDConverter.get_note_db_id(db, note_id)
        if not db_note_id:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨", request_id=getattr(request.state, "request_id", None))
        
        # éªŒè¯ç¬”è®°å±äºå½“å‰ç”¨æˆ·
        note_stmt = select(Note).where(
            Note.id == db_note_id,
            Note.user_id == current_user.id,
            Note.is_deleted == False
        )
        note_result = await db.execute(note_stmt)
        note = note_result.scalar_one_or_none()
        
        if not note:
            return ErrorResponse(msg="ç¬”è®°ä¸å­˜åœ¨æˆ–æ— æƒé™", request_id=getattr(request.state, "request_id", None))
        
        # è·å–å…³è”çš„ä¼šè¯ï¼ˆnote_sessionå·²æ”¯æŒpublic_idï¼‰
        sessions = await note_session.get_sessions_by_note(db, note_id)
        primary_session = await note_session.get_primary_session_by_note(db, note_id)
        
        session_list = []
        for session in sessions:
            # è·å–ä¼šè¯çš„æ¶ˆæ¯æ•°é‡å’Œæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆget_chat_messageså·²æ”¯æŒpublic_idï¼‰
            messages = await get_chat_messages(db, session.public_id)
            message_count = len(messages) if messages else 0
            
            # è·å–æœ€åä¸€æ¡æ¶ˆæ¯å†…å®¹
            last_message = None
            if message_count > 0:
                last_message = messages[-1].content if messages[-1].content else None
            
            # å®‰å…¨åœ°è·å–agent_id
            agent_public_id = None
            if session.agent_id:
                agent_public_id = await IDConverter.get_agent_public_id(db, session.agent_id)
            
            session_info = {
                "id": session.public_id,
                "title": session.title,
                "is_primary": session.id == (primary_session.id if primary_session else None),
                "agent_id": agent_public_id,
                "message_count": message_count,
                "last_message": last_message,
                "created_at": session.created_at.isoformat() if session.created_at else None,
                "updated_at": session.updated_at.isoformat() if session.updated_at else None
            }
            session_list.append(session_info)
        
        return SuccessResponse(
            data={
                "note_id": note_id,
                "sessions": session_list
            },
            msg="è·å–ç¬”è®°ä¼šè¯åˆ—è¡¨æˆåŠŸ",
            request_id=getattr(request.state, "request_id", None)
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ç¬”è®°ä¼šè¯åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}") 